'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = singleSpaAngular2;
var defaultOpts = {
  // required opts
  angularPlatform: null,
  mainModule: null,
  template: null,
  // optional opts
  Router: null,
  domElementGetter: null // only optional if you provide a domElementGetter as a custom prop
};

function singleSpaAngular2(userOpts) {
  if ((typeof userOpts === 'undefined' ? 'undefined' : _typeof(userOpts)) !== 'object') {
    throw new Error('single-spa-angular2 requires a configuration object');
  }

  var opts = _extends({}, defaultOpts, userOpts);

  if (!opts.angularPlatform) {
    throw new Error('single-spa-angular2 must be passed opts.angularPlatform. Usually this should be the return value of platformBrowserDynamic()');
  }

  if (!opts.mainModule) {
    throw new Error('single-spa-angular2 must be passed opts.mainModule, which is the Angular module to bootstrap');
  }

  if (typeof opts.template !== 'string') {
    throw new Error('single-spa-angular2 must be passed opts.template string');
  }

  return {
    bootstrap: bootstrap.bind(null, opts),
    mount: mount.bind(null, opts),
    unmount: unmount.bind(null, opts)
  };
}

function bootstrap(opts) {
  return Promise.resolve();
}

function mount(opts, props) {
  return Promise.resolve().then(function () {
    var domElementGetter = chooseDomElementGetter(opts, props);
    if (!domElementGetter) {
      throw new Error('cannot mount angular application \'' + (props.name || props.appName) + '\' without a domElementGetter provided either as an opt or a prop');
    }

    var containerEl = getContainerEl(domElementGetter);
    containerEl.innerHTML = opts.template;
  }).then(function () {
    return opts.angularPlatform.bootstrapModule(opts.mainModule).then(function (module) {
      return opts.bootstrappedModule = module;
    });
  });
}

function unmount(opts, props) {
  return new Promise(function (resolve, reject) {
    if (opts.Router) {
      var routerRef = opts.bootstrappedModule.injector.get(opts.Router);
      routerRef.dispose();
    }
    opts.bootstrappedModule.destroy();
    delete opts.bootstrappedModule;
    resolve();
  });
}

function getContainerEl(domElementGetter) {
  var element = domElementGetter();
  if (!element) {
    throw new Error('domElementGetter did not return a valid dom element');
  }

  return element;
}

function chooseDomElementGetter(opts, props) {
  return props && props.customProps && props.customProps.domElementGetter ? props.customProps.domElementGetter : opts.domElementGetter;
}
//# sourceMappingURL=single-spa-angular2.js.map